{
	# Global options
	auto_https off
	admin off
	
	# Server options
	servers {
		protocols h1 h2
	}
}

# Subdomain Format Support:
# - ws-<uuid>.*           : Cloud workspaces (auto-generated)
# - local-<name>.*        : Free tier local tunnels
# - <custom-name>.*       : Paid tier custom subdomains
# - Reserved (blocked):    api, tunnel, www, admin, etc.
#
# All formats work with the existing regex: ^([^.]+)\.gitterm\.dev$
# Reserved subdomains are blocked at both workspace creation and Caddy level.

# Listen on port 80 for all requests
:80 {
	# Health check endpoint
	handle /health {
		header Content-Type application/json
		respond `{"status":"UP"}` 200
	}

	# Block reserved subdomains at the Caddy level (defense in depth)
	# These should already be blocked at workspace creation, but this provides an extra layer
	@reserved_subdomain header_regexp subdomain Host ^(api|tunnel)\.gitterm\.dev$
	handle @reserved_subdomain {
		header Content-Type application/json
		respond `{"error":"This subdomain is reserved for system use"}` 403
	}

	# Main proxy handler  
	handle {
		# Forward auth to API server (validates workspace exists and user has access)
		forward_auth server.railway.internal:8080 {
			uri /internal/proxy-resolve

			# Copy select headers from auth response into request
			copy_headers X-Tunnel-Type X-Workspace-ID X-User-ID X-Subdomain

			# Copy original headers
			header_up Host {host}
			header_up X-Internal-Key "EdBY7UDhP-bVJbAns_E9yiFbx_B!tg_"
			header_up Cookie {header.Cookie}
			header_up Authorization {header.Authorization}
			header_up X-Original-URI {uri}
			header_up X-Original-Method {method}
			header_up X-Forwarded-For {remote_ip}
		}

		# Define matchers
		@local_tunnel header X-Tunnel-Type local
		@workspace header_regexp subdomain Host ^([^.]+)\.gitterm\.dev$

		# Local tunnels: Handle FIRST (order matters!)
		handle @local_tunnel {
			reverse_proxy tunnel-proxy.railway.internal:9000 {
				# WebSocket support
				header_up Upgrade {header.Upgrade}
				header_up Connection {header.Connection}
				header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
				header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
				header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
				header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}

				# Standard proxy headers
				header_up Host {host}
				header_up X-Real-IP {remote_ip}
				header_up X-Forwarded-For {remote_ip}
				header_up X-User-Agent {header.User-Agent}
				header_up Cookie {header.Cookie}
				header_up X-Subdomain {header.X-Subdomain}
				header_up X-Tunnel-Type {header.X-Tunnel-Type}

				transport http {
					compression off
					dial_timeout 10s
					response_header_timeout 0
					expect_continue_timeout 0
					keepalive 2m
					keepalive_idle_conns 10
					read_buffer 32768
					write_buffer 32768
				}
			}
		}

		# Cloud workspaces: Handle SECOND
		handle @workspace {
			reverse_proxy {http.regexp.subdomain.1}.railway.internal:7681 {
			# WebSocket support
			header_up Upgrade {header.Upgrade}
			header_up Connection {header.Connection}
			header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
			header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
			header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
			header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}
			
			# Standard proxy headers
			header_up Host {host}
			header_up X-Real-IP {remote_ip}
			header_up X-Forwarded-For {remote_ip}
			header_up User-Agent {header.User-Agent}
			header_up Cookie {header.Cookie}
			
			# Transport settings optimized for WebSocket/ttyd
			transport http {
				compression off
				dial_timeout 10s
				response_header_timeout 0
				expect_continue_timeout 0
				keepalive 2m
				keepalive_idle_conns 10
				read_buffer 32768
				write_buffer 32768
			}
		}
	}

	# Error handling
	handle_errors {
		@400 expression {err.status_code} == 400
		@401 expression {err.status_code} == 401
		@403 expression {err.status_code} == 403
		@404 expression {err.status_code} == 404
		@500 expression {err.status_code} >= 500

		header Content-Type application/json
		
		respond @400 `{"error": "Bad Request"}` 400
		respond @401 `{"error": "Unauthorized"}` 401
		respond @403 `{"error": "Forbidden"}` 403
		respond @404 `{"error": "Workspace not found"}` 404
		respond @500 `{"error": "Internal Server Error"}` 500
		
		# Default error
		respond `{"error": "An error occurred"}` {err.status_code}
	}
}
