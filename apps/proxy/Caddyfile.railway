{
	# Global options
	auto_https off
	admin off

	# Enable debug logging to see what's happening
	log {
		level DEBUG
	}

	# Server options
	servers {
		protocols h1 h2
	}
}

# UNIFIED RAILWAY ROUTING
#
# All services behind a single domain - no cross-origin issues.
# Similar to local development (Caddyfile.local) but for Railway.
#
# URL Structure:
# - /*              -> Web app (Next.js) - DEFAULT
# - /api/*          -> API server
# - /api/trpc/*     -> API server tRPC (strip /api prefix)
# - /listener/*     -> Listener (SSE/tRPC)
# - /tunnel/*       -> Tunnel-proxy (agent WebSocket connections)
# - /ws/{subdomain}/* -> Workspace traffic (path-based routing)
#
# Environment Variables:
# - WEB_URL         -> e.g., web.railway.internal:8080 or public URL
# - SERVER_URL      -> e.g., server.railway.internal:8080 or public URL  
# - LISTENER_URL    -> e.g., listener.railway.internal:8080 or public URL
# - TUNNEL_PROXY_URL -> e.g., tunnel.railway.internal:8080 or public URL
# - INTERNAL_API_KEY -> Shared key for internal API calls
#
# IMPORTANT: For Railway internal networking, service names must match exactly.
# The format is: <service-name>.railway.internal (no port needed for internal)

:80 {
	# Health check endpoint
	handle /health {
		header Content-Type application/json
		respond `{"status":"UP","mode":"railway"}` 200
	}

	# Debug endpoint - shows env var values (remove in production)
	handle /debug {
		header Content-Type application/json
		respond `{"WEB_URL":"{$WEB_URL}","SERVER_URL":"{$SERVER_URL}","LISTENER_URL":"{$LISTENER_URL}","TUNNEL_PROXY_URL":"{$TUNNEL_PROXY_URL}"}` 200
	}

	# ============================================
	# tRPC: /api/trpc/* -> SERVER_URL/trpc/*
	# Strip /api prefix, keep /trpc
	# ============================================
	handle /api/trpc/* {
		uri strip_prefix /api
		reverse_proxy {$SERVER_URL} {
			header_up X-Forwarded-Proto https
			header_up X-Forwarded-Host {host}
		}
	}

	# ============================================
	# API Server: /api/* -> SERVER_URL
	# Keep /api prefix (server expects it for auth, device, agent routes)
	# ============================================
	handle /api/* {
		reverse_proxy {$SERVER_URL} {
			header_up X-Forwarded-Proto https
			header_up X-Forwarded-Host {host}
		}
	}

	# ============================================
	# Listener (SSE/tRPC): /listener/* -> LISTENER_URL
	# Strip /listener prefix
	# ============================================
	handle_path /listener/* {
		reverse_proxy {$LISTENER_URL}
	}

	# ============================================
	# Tunnel-proxy WebSocket: /tunnel/* -> TUNNEL_PROXY_URL
	# For agent connections only (not workspace traffic)
	# ============================================
	handle /tunnel/* {
		reverse_proxy {$TUNNEL_PROXY_URL} {
			header_up Upgrade {header.Upgrade}
			header_up Connection {header.Connection}
		}
	}

	# ============================================
	# PATH-BASED WORKSPACE ROUTING: /ws/{subdomain}/*
	# Routes workspace traffic based on hosting type:
	# - local: tunnel-proxy (TUNNEL_PROXY_URL)
	# - cloud: Railway container URL (with path prefix stripped)
	# ============================================
	handle /ws/* {
		# Forward auth to API server (validates workspace exists and user has access)
		forward_auth {$SERVER_URL} {
			uri /api/internal/proxy-resolve

			copy_headers X-Hosting-Type X-Workspace-ID X-User-ID X-Subdomain X-Upstream-URL X-Container-Host X-Container-Port X-Container-Protocol

			header_up Host {host}
			header_up X-Internal-Key {$INTERNAL_API_KEY}
			header_up Cookie {header.Cookie}
			header_up Authorization {header.Authorization}
			header_up X-Original-URI {uri}
			header_up X-Original-Method {method}
			header_up X-Forwarded-For {remote_ip}
			header_up X-Routing-Mode path
		}

		# Local workspaces: route to tunnel-proxy (keep full path)
		@local_workspace header X-Hosting-Type local
		reverse_proxy @local_workspace {$TUNNEL_PROXY_URL} {
			header_up Upgrade {header.Upgrade}
			header_up Connection {header.Connection}
			header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
			header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
			header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
			header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}
			header_up Host {host}
			header_up X-Real-IP {remote_ip}
			header_up X-Forwarded-For {remote_ip}
			header_up X-User-Agent {header.User-Agent}
			header_up Cookie {header.Cookie}
			header_up X-Subdomain {header.X-Subdomain}
			header_up X-Hosting-Type {header.X-Hosting-Type}
			header_up X-Routing-Mode path

			# Modify CSP header to allow data URIs for WebAssembly
			header_down Content-Security-Policy "default-src 'self'; connect-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; worker-src 'self' blob:;"
			

			transport http {
				compression off
				dial_timeout 10s
				response_header_timeout 0
				expect_continue_timeout 0
				keepalive 2m
				keepalive_idle_conns 10
			}
		}

		# Cloud workspaces: strip /ws/{subdomain} prefix and proxy to container
		@cloud_workspace header X-Hosting-Type cloud
		route @cloud_workspace {
			# Strip /ws/{subdomain} prefix: /ws/abc123/foo -> /foo, /ws/abc123 -> /
			uri path_regexp "^/ws/[^/]+(/.*)$" "$1"
			uri path_regexp "^/ws/[^/]+/?$" "/"

			reverse_proxy {header.X-Container-Host}:{header.X-Container-Port} {
				header_up Upgrade {header.Upgrade}
				header_up Connection {header.Connection}
				header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
				header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
				header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
				header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}
				header_up Host {header.X-Container-Host}
				header_up X-Real-IP {remote_ip}
				header_up X-Forwarded-For {remote_ip}
				header_up User-Agent {header.User-Agent}
				header_up Cookie {header.Cookie}

				# Modify CSP header to allow data URIs for WebAssembly
				header_down Content-Security-Policy "default-src 'self'; connect-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; worker-src 'self' blob:;"
		

				transport http {
					compression off
					dial_timeout 10s
					response_header_timeout 0
					expect_continue_timeout 0
					keepalive 2m
					keepalive_idle_conns 10
				}
			}
		}
	}

	# ============================================
	# Default: Everything else -> Web App (Next.js)
	# This MUST be last - it's the fallback for all unmatched routes
	# ============================================
	handle {
		reverse_proxy {$WEB_URL}
	}

	# Error handling
	handle_errors {
		@502_503 expression {err.status_code} == 502 || {err.status_code} == 503
		handle @502_503 {
			header Content-Type text/html
			respond "Upstream unavailable - check WEB_URL, SERVER_URL env vars" 503
		}

		handle {
			header Content-Type text/html
			respond "Error {err.status_code}" {err.status_code}
		}
	}
}
