{
	# Global options for local development
	auto_https off
	admin off

	# Server options
	servers {
		protocols h1 h2
	}
}

# Local Development Caddy Configuration
#
# All traffic goes through a single domain (localhost:8888).
# No DNS configuration or /etc/hosts required!
#
# URL Structure:
# - /*              -> Web app (Next.js) - DEFAULT
# - /api/*          -> API server
# - /listener/*     -> Listener (SSE/tRPC)
# - /tunnel/*       -> Tunnel-proxy (agent WebSocket connections)
# - /ws/{subdomain}/* -> Workspace traffic (path-based routing)
#
# Backend Ports (local dev):
# - 8888: Caddy (this proxy) - the main entry point
# - 3000: Server (API)
# - 3001: Web (Next.js)
# - 3003: Listener (SSE)
# - 9000: Tunnel-proxy (agent connections + workspace traffic)
#
# Prerequisites:
# - Install Caddy: brew install caddy (macOS) or see https://caddyserver.com/docs/install

# Listen on port 8888 for all requests
:8888 {
	# Health check endpoint
	handle /health {
		header Content-Type application/json
		respond `{"status":"UP"}` 200
	}

	# ============================================
	# tRPC: /api/trpc/* -> localhost:3000/trpc/*
	# Strip /api prefix, keep /trpc
	# ============================================
	handle /api/trpc/* {
		uri strip_prefix /api
		reverse_proxy localhost:3000
	}

	# ============================================
	# API Server: /api/* -> localhost:3000
	# Keep /api prefix (server expects it for auth, device, agent routes)
	# ============================================
	handle /api/* {
		reverse_proxy localhost:3000
	}

	# ============================================
	# Listener (SSE/tRPC): /listener/* -> localhost:3003
	# Strip /listener prefix, forward as /trpc/*
	# ============================================
	handle_path /listener/* {
		reverse_proxy localhost:3003
	}

	# ============================================
	# Tunnel-proxy WebSocket: /tunnel/* -> localhost:9000
	# For agent connections only (not workspace traffic)
	# ============================================
	handle /tunnel/* {
		reverse_proxy localhost:9000 {
			# WebSocket support
			header_up Upgrade {header.Upgrade}
			header_up Connection {header.Connection}
		}
	}

	# ============================================
	# PATH-BASED WORKSPACE ROUTING: /ws/{subdomain}/*
	# Routes workspace traffic based on hosting type:
	# - local: tunnel-proxy (localhost:9000)
	# - cloud: Railway public URL (with path prefix stripped)
	# ============================================
	handle /ws/* {
		# Forward auth to API server (validates workspace exists and user has access)
		forward_auth localhost:3000 {
			uri /api/internal/proxy-resolve

			copy_headers X-Hosting-Type X-Workspace-ID X-User-ID X-Subdomain X-Upstream-URL X-Container-Host X-Container-Port X-Container-Protocol

			header_up Host {host}
			header_up X-Internal-Key {$INTERNAL_API_KEY}
			header_up Cookie {header.Cookie}
			header_up Authorization {header.Authorization}
			header_up X-Original-URI {uri}
			header_up X-Original-Method {method}
			header_up X-Forwarded-For {remote_ip}
			header_up X-Routing-Mode path
		}

		# Local workspaces: route to tunnel-proxy (keep full path)
		@local_workspace header X-Hosting-Type local
		reverse_proxy @local_workspace localhost:9000 {
			header_up Upgrade {header.Upgrade}
			header_up Connection {header.Connection}
			header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
			header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
			header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
			header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}
			header_up Host {host}
			header_up X-Real-IP {remote_ip}
			header_up X-Forwarded-For {remote_ip}
			header_up X-User-Agent {header.User-Agent}
			header_up Cookie {header.Cookie}
			header_up X-Subdomain {header.X-Subdomain}
			header_up X-Hosting-Type {header.X-Hosting-Type}
			header_up X-Routing-Mode path

			# Modify CSP header to allow data URIs for WebAssembly
			header_down Content-Security-Policy "default-src 'self'; connect-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; worker-src 'self' blob:;"
	

			transport http {
				compression off
				dial_timeout 10s
				response_header_timeout 0
				expect_continue_timeout 0
				keepalive 2m
				keepalive_idle_conns 10
			}
		}

		# Cloud workspaces: strip /ws/{subdomain} prefix and proxy to Railway
		@cloud_workspace header X-Hosting-Type cloud
		route @cloud_workspace {
			# Strip /ws/{subdomain} prefix: /ws/abc123/foo -> /foo, /ws/abc123 -> /
			uri path_regexp "^/ws/[^/]+(/.*)$" "$1"
			uri path_regexp "^/ws/[^/]+/?$" "/"

			reverse_proxy {header.X-Container-Host}:{header.X-Container-Port} {
				header_up Upgrade {header.Upgrade}
				header_up Connection {header.Connection}
				header_up Sec-WebSocket-Key {header.Sec-WebSocket-Key}
				header_up Sec-WebSocket-Version {header.Sec-WebSocket-Version}
				header_up Sec-WebSocket-Protocol {header.Sec-WebSocket-Protocol}
				header_up Sec-WebSocket-Extensions {header.Sec-WebSocket-Extensions}
				header_up Host {header.X-Container-Host}
				header_up X-Real-IP {remote_ip}
				header_up X-Forwarded-For {remote_ip}
				header_up User-Agent {header.User-Agent}
				header_up Cookie {header.Cookie}

				# Modify CSP header to allow data URIs for WebAssembly
				header_down Content-Security-Policy "default-src 'self'; connect-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; worker-src 'self' blob:;"
		

				transport http {
					tls
					tls_insecure_skip_verify
				}
			}
		}
	}

	# ============================================
	# Default: Everything else -> Web App (Next.js)
	# This is the fallback, so frontend is at root
	# ============================================
	handle {
		reverse_proxy localhost:3001
	}

	# Error handling
	handle_errors {
		@unavailable expression {err.status_code} == 401 || {err.status_code} == 403 || {err.status_code} == 404
		handle @unavailable {
			header Content-Type text/html
			respond "Service unavailable" {err.status_code}
		}

		@server_error expression {err.status_code} >= 500
		handle @server_error {
			header Content-Type text/html
			respond "Server error" {err.status_code}
		}

		handle {
			header Content-Type text/html
			respond "Error" 500
		}
	}
}
